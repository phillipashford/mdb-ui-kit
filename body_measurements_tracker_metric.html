<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Local Body Measurements Tracker — Metric + BMI</title>
<style>
  :root{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;--card:#fff;--muted:#666}
  body{background:#f2f4f7;color:#111;margin:0;padding:16px}
  header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
  h1{font-size:18px;margin:0}
  .card{background:var(--card);border-radius:10px;padding:12px;box-shadow:0 1px 2px rgba(0,0,0,.06);margin-bottom:12px}
  label{display:block;font-size:13px;margin-top:6px}
  .grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
  input[type="number"], input[type="date"], input[type="text"]{width:100%;padding:8px;border-radius:6px;border:1px solid #d0d5dd}
  .row{display:flex;gap:8px;align-items:center}
  button{background:#0b78e3;color:#fff;border:none;padding:8px 10px;border-radius:8px;font-weight:600}
  .btn-ghost{background:#fff;border:1px solid #d0d5dd;color:#111}
  table{width:100%;border-collapse:collapse;font-size:13px}
  th,td{padding:6px 8px;text-align:left;border-bottom:1px solid #eef2f7}
  .muted{color:var(--muted);font-size:13px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .metric-checkbox{display:inline-flex;align-items:center;gap:6px;margin-right:8px;cursor:pointer}
  canvas{width:100%;height:320px;background:#fff;border-radius:8px}
  .small{font-size:12px;color:#555}
  .danger{background:#ff4d4f}
  footer{font-size:12px;color:#666;margin-top:8px}
  .settings{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .pill{padding:6px 8px;border-radius:999px;border:1px solid #e0e6ef;background:#fff}
  .legend-item{display:inline-flex;align-items:center;gap:6px;margin-right:10px;cursor:pointer}
  .activeMetric{font-weight:700}
  @media (max-width:520px){.grid{grid-template-columns:1fr}}
</style>
</head>
<body>
<header>
  <h1>Local Body Measurements Tracker — Metric</h1>
</header>

<div class="card">
  <div class="small muted">Settings — stored locally. Height required for BMI calculation. Units: Metric (kg, cm).</div>
  <div style="margin-top:8px" class="settings">
    <label class="pill">Height (cm)<input id="heightCm" type="number" step="0.1" style="margin-left:8px;width:90px" placeholder="180"></label>
    <label class="pill">Default weight unit: kg</label>
    <button id="saveSettings" class="btn-ghost">Save</button>
    <div style="margin-left:auto" class="small muted">Settings stored locally.</div>
  </div>
</div>

<div class="card">
  <div class="small muted">1) Add a new measurement (date + values). Data is stored locally in Safari only.</div>
  <div style="margin-top:8px;" class="grid">
    <div>
      <label for="date">Date</label>
      <input id="date" type="date"/>
    </div>
    <div>
      <label for="notes">Notes (optional)</label>
      <input id="notes" type="text" placeholder="e.g. after workout"/>
    </div>

    <!-- Ten common metrics (metric units) -->
    <div>
      <label for="weight">Weight (kg)</label>
      <input id="weight" type="number" step="0.1" placeholder="e.g. 78.4"/>
    </div>
    <div>
      <label for="bodyfat">Body Fat %</label>
      <input id="bodyfat" type="number" step="0.1" placeholder="e.g. 18.5"/>
    </div>

    <div>
      <label for="waist">Waist (cm)</label>
      <input id="waist" type="number" step="0.1" placeholder="e.g. 85"/>
    </div>
    <div>
      <label for="hips">Hips (cm)</label>
      <input id="hips" type="number" step="0.1" placeholder="e.g. 98"/>
    </div>

    <div>
      <label for="chest">Chest (cm)</label>
      <input id="chest" type="number" step="0.1" placeholder="e.g. 102"/>
    </div>
    <div>
      <label for="neck">Neck (cm)</label>
      <input id="neck" type="number" step="0.1" placeholder="e.g. 38"/>
    </div>

    <div>
      <label for="biceps_l">Left Biceps (cm)</label>
      <input id="biceps_l" type="number" step="0.1" placeholder="e.g. 34"/>
    </div>
    <div>
      <label for="biceps_r">Right Biceps (cm)</label>
      <input id="biceps_r" type="number" step="0.1" placeholder="e.g. 34"/>
    </div>

    <div>
      <label for="thigh_l">Left Thigh (cm)</label>
      <input id="thigh_l" type="number" step="0.1" placeholder="e.g. 58"/>
    </div>
    <div>
      <label for="thigh_r">Right Thigh (cm)</label>
      <input id="thigh_r" type="number" step="0.1" placeholder="e.g. 58"/>
    </div>
  </div>

  <div style="margin-top:10px" class="row">
    <button id="saveBtn">Save Entry</button>
    <button id="clearBtn" class="btn-ghost">Clear All Data</button>
    <button id="exportBtn" class="btn-ghost">Export JSON</button>
    <div style="margin-left:auto" class="small muted">Storage: <span id="storageInfo">—</span></div>
  </div>
</div>

<div class="card">
  <div class="small muted">2) Charting. Tap a metric name to view that metric standalone (recommended). Use smoothing and trendline options.</div>
  <div id="metricControls" class="controls" style="margin-top:8px"></div>

  <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
    <label class="pill">Smoothing
      <select id="smoothingSelect" style="margin-left:8px">
        <option value="none">None</option>
        <option value="weekly">Weekly (7-day moving avg)</option>
        <option value="monthly">Monthly (30-day moving avg)</option>
      </select>
    </label>

    <label class="pill"><input id="trendToggle" type="checkbox" style="margin-right:6px"> Show trend line</label>

    <button id="exportPng" class="btn-ghost" style="margin-left:auto">Export chart PNG</button>
  </div>

  <canvas id="chartCanvas"></canvas>
  <div id="chartHint" class="small muted" style="margin-top:6px">Tap a metric name to open standalone chart. Use checkboxes to toggle series in multi-mode.</div>
</div>

<div class="card">
  <div class="small muted">3) Data table (most recent first). Tap an entry to edit.</div>
  <div id="tableWrap" style="overflow:auto;max-height:260px;margin-top:8px"></div>
</div>

<footer class="small muted">
  This file is FOSS and stores all data in your browser on the device. To keep it local: Open in Safari → Share → "Add to Home Screen". Do not enable iCloud sync for Safari if you want data strictly on-device.
</footer>

<script>
/* ====== Configuration ====== */
let METRICS = [
  {key:'weight', label:'Weight (kg)', editable:true},
  {key:'bodyfat', label:'Body Fat %', editable:true},
  {key:'waist', label:'Waist (cm)', editable:true},
  {key:'hips', label:'Hips (cm)', editable:true},
  {key:'chest', label:'Chest (cm)', editable:true},
  {key:'neck', label:'Neck (cm)', editable:true},
  {key:'biceps_l', label:'Left Biceps (cm)', editable:true},
  {key:'biceps_r', label:'Right Biceps (cm)', editable:true},
  {key:'thigh_l', label:'Left Thigh (cm)', editable:true},
  {key:'thigh_r', label:'Right Thigh (cm)', editable:true},
  // computed metrics (not editable)
  {key:'bmi', label:'BMI (kg/m²)', editable:false, computed:true},
  {key:'leanmass', label:'Lean Mass (kg)', editable:false, computed:true}
];
const STORAGE_KEY = 'local_body_tracker_v1';
const SETTINGS_KEY = 'local_body_tracker_settings_v1';

/* ====== Utilities ====== */
function uid(){return Math.random().toString(36).slice(2,9)}
function todayISO(){return new Date().toISOString().slice(0,10)}
function readData(){ try{ return JSON.parse(localStorage.getItem(STORAGE_KEY)||'[]') }catch(e){return []} }
function writeData(d){ localStorage.setItem(STORAGE_KEY, JSON.stringify(d)) }
function readSettings(){ try{ return JSON.parse(localStorage.getItem(SETTINGS_KEY)||'{}') }catch(e){return {} } }
function writeSettings(s){ localStorage.setItem(SETTINGS_KEY, JSON.stringify(s)) }

/* ====== Init UI ====== */
document.getElementById('date').value = todayISO();
const metricControls = document.getElementById('metricControls');

// render metric controls (checkbox + clickable label for standalone)
function renderMetricControls(){
  metricControls.innerHTML = '';
  METRICS.forEach((m,i)=>{
    if(m.computed) return; // computed metrics not in selection list for multi-series
    const el = document.createElement('label');
    el.className = 'metric-checkbox';
    el.innerHTML = `<input type="checkbox" data-key="${m.key}" ${i<3?'checked':''}/> <span data-key="${m.key}" class="metric-name">${m.label}</span>`;
    metricControls.appendChild(el);
  });
  // clickable metric names open standalone chart
  document.querySelectorAll('.metric-name').forEach(el=>{
    el.addEventListener('click', (ev)=>{
      const key = el.getAttribute('data-key');
      openStandaloneMetric(key);
    });
  });
}
renderMetricControls();

document.getElementById('storageInfo').textContent = (localStorage.getItem(STORAGE_KEY)? 'saved' : 'empty');

/* Settings load/save */
const settings = readSettings();
if(settings.heightCm) document.getElementById('heightCm').value = settings.heightCm;
document.getElementById('saveSettings').addEventListener('click', ()=>{
  const h = parseFloat(document.getElementById('heightCm').value);
  if(!h || h <= 0){ alert('Please enter a valid height in cm for BMI calculation.'); return; }
  writeSettings({heightCm: h});
  alert('Settings saved.');
});

/* ====== Save / Clear / Export ====== */
document.getElementById('saveBtn').addEventListener('click', saveEntry);
document.getElementById('clearBtn').addEventListener('click', ()=>{
  if(!confirm('Clear all local data? This cannot be undone.')) return;
  localStorage.removeItem(STORAGE_KEY);
  refreshAll();
});
document.getElementById('exportBtn').addEventListener('click', ()=>{
  const data = readData();
  const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'body-measurements-export.json'; a.click();
  URL.revokeObjectURL(url);
});

function saveEntry(){
  const date = document.getElementById('date').value;
  if(!date){ alert('Please pick a date'); return; }
  const notes = document.getElementById('notes').value || '';
  const entry = { id: uid(), date, notes, values: {} };
  METRICS.forEach(m=>{
    if(m.computed) return;
    const el = document.getElementById(m.key);
    if(!el) return;
    const v = el.value;
    if(v !== '') entry.values[m.key] = parseFloat(v);
  });
  // computed fields will be derived when rendering/charting
  const data = readData();
  const existingIndex = data.findIndex(r=>r.date === date);
  if(existingIndex >= 0){
    if(!confirm('An entry for this date exists. Overwrite it?')) return;
    data.splice(existingIndex,1,entry);
  } else {
    data.push(entry);
  }
  data.sort((a,b)=> new Date(a.date) - new Date(b.date));
  writeData(data);
  refreshAll();
  METRICS.forEach(m=>{ if(!m.computed){ const el = document.getElementById(m.key); if(el) el.value=''; } });
}

/* ====== Table ====== */
function renderTable(){
  const data = readData().slice().reverse(); // most recent first
  const wrap = document.getElementById('tableWrap');
  if(!data.length){ wrap.innerHTML = '<div class="small muted">No entries yet.</div>'; return; }
  let html = '<table><thead><tr><th>Date</th><th>Notes</th>';
  METRICS.forEach(m=> html += `<th>${m.label}</th>`);
  html += '<th></th></tr></thead><tbody>';
  data.forEach(r=>{
    html += `<tr data-id="${r.id}"><td style="white-space:nowrap">${r.date}</td><td>${(r.notes||'')}</td>`;
    // show values including computed
    const computedRow = computeDerived(r);
    METRICS.forEach(m=>{
      const v = (computedRow && computedRow[m.key] !== undefined) ? computedRow[m.key] : '';
      html += `<td>${(v!==null && v!==undefined && v!=='' ? v : '')}</td>`;
    });
    html += `<td style="white-space:nowrap"><button class="btn-ghost" data-edit="${r.id}">Edit</button> <button class="btn-ghost" data-delete="${r.id}">Delete</button></td></tr>`;
  });
  html += '</tbody></table>';
  wrap.innerHTML = html;
  // attach handlers
  wrap.querySelectorAll('[data-delete]').forEach(btn=>{
    btn.addEventListener('click', (ev)=>{
      const id = ev.target.getAttribute('data-delete');
      if(!confirm('Delete entry?')) return;
      let d = readData(); d = d.filter(x=> x.id !== id); writeData(d); refreshAll();
    });
  });
  wrap.querySelectorAll('[data-edit]').forEach(btn=>{
    btn.addEventListener('click', (ev)=>{
      const id = ev.target.getAttribute('data-edit');
      const d = readData(); const entry = d.find(x=> x.id === id);
      if(!entry) return;
      document.getElementById('date').value = entry.date;
      document.getElementById('notes').value = entry.notes || '';
      METRICS.forEach(m=>{
        if(m.computed) return;
        const el = document.getElementById(m.key);
        if(el) el.value = (entry.values && entry.values[m.key] !== undefined) ? entry.values[m.key] : '';
      });
      window.scrollTo({top:0,behavior:'smooth'});
    });
  });
}

/* ====== Derived metrics ====== */
function computeDerived(entry){
  // return object with all METRICS keys, computing bmi and leanmass if possible
  const out = {};
  METRICS.forEach(m=>{
    if(!m.computed){
      out[m.key] = (entry.values && entry.values[m.key] !== undefined) ? entry.values[m.key] : null;
    }
  });
  const settings = readSettings();
  const heightCm = settings.heightCm;
  const weight = out['weight'];
  const bodyfat = out['bodyfat'];
  if(heightCm && weight){
    const h_m = heightCm / 100;
    const bmi = +(weight / (h_m*h_m)).toFixed(2);
    out['bmi'] = bmi;
  } else {
    out['bmi'] = null;
  }
  if(weight !== null && bodyfat !== null && !isNaN(bodyfat)){
    const lm = +(weight * (1 - (bodyfat/100))).toFixed(2);
    out['leanmass'] = lm;
  } else {
    out['leanmass'] = null;
  }
  return out;
}

/* ====== Charting ====== */
const canvas = document.getElementById('chartCanvas');
const ctx = canvas.getContext('2d');

function devicePixelRatioFix(){
  const ratio = window.devicePixelRatio || 1;
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;
  canvas.width = Math.floor(w * ratio);
  canvas.height = Math.floor(h * ratio);
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  ctx.setTransform(ratio,0,0,ratio,0,0);
}
window.addEventListener('resize', ()=>{ devicePixelRatioFix(); renderChart(); });

function getCheckedMetrics(){
  const boxes = Array.from(document.querySelectorAll('#metricControls input[type=checkbox]'));
  return boxes.filter(b=>b.checked).map(b=>b.getAttribute('data-key'));
}

function gatherSeriesForKey(key){
  const data = readData();
  // map dates to values (computed included)
  const series = data.map(r=>{
    const comp = computeDerived(r);
    return {date: r.date, value: (comp && comp[key] !== undefined ? comp[key] : null)};
  });
  return series;
}

function renderChart(activeMetric=null){
  devicePixelRatioFix();
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const data = readData();
  if(!data.length){ drawNoData(); return; }

  let keys;
  if(activeMetric){
    keys = [activeMetric];
  } else {
    keys = getCheckedMetrics();
  }
  if(!keys.length){ drawNoMetric(); return; }

  // prepare x labels (dates)
  const dates = data.map(r=> r.date);
  const parsedDates = dates.map(d=> new Date(d));
  const xLabels = dates;

  // build series objects
  const series = keys.map(k=>{
    const s = gatherSeriesForKey(k);
    return {key:k, points: s};
  });

  // apply smoothing option if selected
  const smoothing = document.getElementById('smoothingSelect').value; // none, weekly, monthly
  const smoothWindow = smoothing === 'weekly' ? 7 : (smoothing === 'monthly' ? 30 : 1);

  // compute y min/max
  let globalMin = Infinity, globalMax = -Infinity;
  series.forEach(s=>{
    // apply smoothing to produce displayValues
    const rawVals = s.points.map(p=>p.value);
    const vals = smoothWindow > 1 ? movingAverageByDate(s.points, smoothWindow) : rawVals;
    s.displayVals = vals;
    vals.forEach(v=>{ if(v !== null && v !== undefined){ if(v < globalMin) globalMin = v; if(v > globalMax) globalMax = v }});
  });
  if(globalMin === Infinity){ drawNoValues(); return; }

  // margins and dims
  const margin = {l:56, r:12, t:20, b:48};
  const W = canvas.clientWidth - margin.l - margin.r;
  const H = canvas.clientHeight - margin.t - margin.b;

  // scales
  const min = globalMin;
  const max = globalMax;
  const range = (max - min) || (Math.abs(max) || 1);
  const yScale = v => margin.t + H - ((v - min) / range) * H;
  const xScale = i => margin.l + (i/(xLabels.length-1 || 1)) * W;

  // gridlines
  ctx.strokeStyle = '#e6e9ee'; ctx.lineWidth = 1;
  ctx.beginPath();
  const yTicks = 4;
  for(let yi=0; yi<=yTicks; yi++){
    const y = margin.t + (yi/yTicks)*H;
    ctx.moveTo(margin.l, y); ctx.lineTo(margin.l+W, y);
  }
  ctx.stroke();

  // y labels
  ctx.fillStyle = '#444';
  ctx.font = '12px system-ui';
  for(let yi=0; yi<=yTicks; yi++){
    const v = +(max - (yi/yTicks)*(range)).toFixed(2);
    const y = margin.t + (yi/yTicks)*H;
    ctx.fillText(v.toString(), 8, y+4);
  }

  // x labels (sparse)
  ctx.fillStyle = '#444';
  const xTickCount = Math.min(6, xLabels.length);
  ctx.font = '12px system-ui';
  for(let xi=0; xi<xTickCount; xi++){
    const idx = Math.round((xi/(xTickCount-1 || 1))*(xLabels.length-1));
    const txt = xLabels[idx];
    const x = xScale(idx);
    ctx.fillText(txt, x-28, margin.t + H + 18);
  }

  // draw series lines and points
  const palette = ['#0b78e3','#ff8c00','#2ca02c','#d62728','#9467bd','#8c564b','#e377c2','#7f7f7f','#17becf','#bcbd22'];
  series.forEach((s, si)=>{
    ctx.beginPath();
    ctx.lineWidth = 2.6;
    ctx.strokeStyle = palette[si % palette.length];
    let started = false;
    s.displayVals.forEach((v, i)=>{
      if(v === null || v === undefined){ started = false; return; }
      const x = xScale(i);
      const y = yScale(v);
      if(!started){ ctx.moveTo(x,y); started = true; } else ctx.lineTo(x,y);
    });
    ctx.stroke();

    // draw points
    ctx.fillStyle = palette[si % palette.length];
    s.displayVals.forEach((v,i)=>{
      if(v === null || v === undefined) return;
      const x = xScale(i);
      const y = yScale(v);
      ctx.beginPath(); ctx.arc(x,y,3.2,0,Math.PI*2); ctx.fill();
    });

    // optional trend line (linear regression) if toggled and single metric
    if(document.getElementById('trendToggle').checked && series.length===1){
      const numericXY = s.points.map((p, idx)=> {
        const vv = s.displayVals[idx];
        if(vv === null || vv === undefined) return null;
        return {x: idx, y: vv};
      }).filter(Boolean);
      if(numericXY.length >= 2){
        const lr = linearRegression(numericXY.map(pt=>pt.x), numericXY.map(pt=>pt.y));
        const x0 = 0, x1 = numericXY[numericXY.length-1].x;
        const y0 = lr.intercept + lr.slope * x0;
        const y1 = lr.intercept + lr.slope * x1;
        ctx.beginPath();
        ctx.lineWidth = 2;
        ctx.setLineDash([6,4]);
        ctx.strokeStyle = '#222';
        ctx.moveTo(xScale(x0), yScale(y0));
        ctx.lineTo(xScale(x1), yScale(y1));
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }
  });

  // legend for series
  const legendY = 12;
  series.forEach((s, si)=>{
    const legendX = margin.l + si*140;
    ctx.fillStyle = palette[si % palette.length];
    ctx.fillRect(legendX, legendY-8, 12, 8);
    ctx.fillStyle = '#222';
    ctx.font = '12px system-ui';
    ctx.fillText(METRICS.find(m=>m.key===s.key).label, legendX+18, legendY);
  });
}

/* ====== Helpers: smoothing, moving average by date (handles nulls) ====== */
function movingAverageByDate(points, windowDays){
  // points: array aligned with all dates in stored order, with value or null
  // We'll compute a simple centered (backward-looking) moving average over windowDays using available numeric values
  const out = [];
  const dates = readData().map(r=> new Date(r.date));
  for(let i=0;i<points.length;i++){
    const start = new Date(dates[i]); start.setDate(start.getDate() - (windowDays-1));
    let sum=0, count=0;
    for(let j=0;j<points.length;j++){
      const d = dates[j];
      if(d >= start && d <= dates[i]){
        const v = points[j].value;
        if(v !== null && v !== undefined && !isNaN(v)){ sum += v; count++; }
      }
    }
    out.push(count? +(sum/count).toFixed(3) : null);
  }
  return out;
}

/* Linear regression util */
function linearRegression(xs, ys){
  const n = xs.length;
  const sx = xs.reduce((a,b)=>a+b,0);
  const sy = ys.reduce((a,b)=>a+b,0);
  const sxx = xs.reduce((a,b)=>a+b*b,0);
  const sxy = xs.reduce((a, b, i)=> a + b*ys[i], 0);
  const slope = (n*sxy - sx*sy) / (n*sxx - sx*sx);
  const intercept = (sy - slope*sx)/n;
  return {slope, intercept};
}

/* Draw placeholders */
function drawNoData(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#777'; ctx.font = '14px system-ui';
  ctx.fillText('No data yet — add an entry above.', 12, 40);
}
function drawNoMetric(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#777'; ctx.font = '14px system-ui';
  ctx.fillText('Select at least one metric to chart.', 12, 40);
}
function drawNoValues(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#777'; ctx.font = '14px system-ui';
  ctx.fillText('Selected metrics have no numeric values.', 12, 40);
}

/* Attach checkbox change */
document.querySelectorAll('#metricControls input[type=checkbox]').forEach(box=>{
  box.addEventListener('change', ()=> renderChart());
});

/* Standalone metric mode */
let standaloneKey = null;
function openStandaloneMetric(key){
  standaloneKey = key;
  // visually mark active metric
  document.querySelectorAll('.metric-name').forEach(el=> el.classList.remove('activeMetric'));
  const el = document.querySelector(`.metric-name[data-key="${key}"]`);
  if(el) el.classList.add('activeMetric');
  renderChart(key);
}

/* Export PNG */
document.getElementById('exportPng').addEventListener('click', ()=>{
  const a = document.createElement('a');
  const dataUrl = canvas.toDataURL('image/png');
  a.href = dataUrl; a.download = 'metric-chart.png'; a.click();
});

/* initial render */
refreshAll();

/* ====== refreshAll ====== */
function refreshAll(){ renderTable(); renderChart(standaloneKey); document.getElementById('storageInfo').textContent = (readData().length? 'saved':'empty') }

/* ====== On load ensure controls reflect current state ====== */
function initControls(){
  document.getElementById('smoothingSelect').addEventListener('change', ()=> renderChart(standaloneKey));
  document.getElementById('trendToggle').addEventListener('change', ()=> renderChart(standaloneKey));
  // Export PNG button in header already bound
}
initControls();

/* ====== utility: compute series for charting access earlier ====== */
function gatherSeriesForKey(key){
  const data = readData();
  const out = data.map(r=>{
    const comp = computeDerived(r);
    return {date: r.date, value: comp[key] !== undefined ? comp[key] : null};
  });
  return out;
}

/* ====== initial helpers to ensure metric controls present after DOM load ====== */
renderMetricControls();

/* Done */
</script>
</body>
</html>
